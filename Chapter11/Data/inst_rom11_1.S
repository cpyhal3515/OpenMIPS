    .org 0x0
    .set noat
    .set noreorder
    .set nomacro
    .global _start 
_start:
    # 因为低地址有异常处理例程, 所以处理器启动后, 就立即转移到 0x100 处
    ori $1, $0, 0x100   #（1）设置寄存器 $1=0x100
    jr $1               # 转移到地址0x100处
nop
    # 系统调用异常处理例程
    .org 0x40
    ori  $1, $0, 0x8000  #（3）设置寄存器$1=0x00008000
    ori  $1, $0, 0x9000  #（4）设置寄存器$1=0x00009000
    mfc0 $1, $14, 0x0    #（5）获取EPC寄存器的值保存到寄存器$1, $1=0x0000010c, 
    addi $1, $1, 0x4     #（6）寄存器$1加4, $1=0x00000110
    mtc0 $1, $14, 0x0    # 将EPC+4的结果保存回EPC寄存器
    eret
    nop

    # 主程序, 在其中调用 syscall 指令, 从而引起系统调用异常D回
    .org 0x100
    ori $1, $0, 0x1000  #（2）设置寄存器$1=0x1000

    sw $1, 0x0100($0)   # 将寄存器 $1 的值存储到内存 0x100 处, 
                        # [0x100] = 0x00001000
    mthi $1             # 将寄存器 $1 的值复制到寄存器 HI, HI=0x00001000
    syscall             # 调用 syscall 指令, 引起系统调用异常
    lw  $1, 0x0100($0)  #（7）从内存 0x100 处加载数据, 保存到寄存器 $1
                        # 所以, 最后 $1=0x00001000
    mfhi $2             # 将寄存器 HI 的值赋给寄存器 $2, $2=0x00001000
_loop:
    j _loop 
    nop