    .org 0x0
    .set noat
    .set noreorder
    .set nomacro
    .global _start 
_start:
    # 因为低地址有异常处理例程, 所以处理器启动后, 就立即转移到 0x100 处
    ori $1, $0, 0x100       # 设置寄存器 $1 = 0x100
    jr $1                   # 转移到地址 0x100 处
    nop

    # 自陷异常的处理例程, 在其中设置寄存器 $1 的值
    .org 0x40
    ori $1, $0, 0xf0f0      #  设置寄存器 $1=0x0000f0f0
    ori $1, $0, 0Xffff      # 设置寄存器 $1=0x0000ffff
    ori $1, $0, 0x0f0f      # 设置寄存器 $1=0x00000f0f

    mfc0 $4, $14, 0x0       # 获取 EPC 寄存器的值, 保存到寄存器 $4
    addi $4, $4, 0x4        # 将寄存器 $4 加 4
    mtc0 $4, $14, 0x0       # 将寄存器 $4 的值赋给 EPC, 
    # 上面三条指令实际就是将EPC寄存器的值加 4

    eret                    # 异常返回
    nop

    # 主程序, 在其中会调用多个自陷指令
    .org 0x100
    ori $1, $0, 0x1000      # $1=0x00001000
    ori $2, $0, 0x1000      # $2=0x00001000
    teq $1, $2              # 此时 $1 等于 $2, 所以发生自陷异常
    
    ori $1, $0, 0x2000      # $1=0x00002000
    tne $1, $2              # 此时$1不等于$2, 所以发生自陷异常
    
    ori  $1, $0, 0x3000     # $1=0x00003000
    teqi $1, 0x3000         # 此时$1等于0x3000, 所以发生自陷异常

    ori  $1, $0, 0x4000     # $1=0x00004000
    tnei $1, 0x2000         # 此时$1不等于0x2000, 所以发生自陷异常
    
    ori  $1, $0, 0x5000     # $1=0x00005000
    tge $1, $2              # 此时$1大于$2, 所以发生自陷异常
    
    ori $1, $0, 0x6000      # $1=0x00006000
    tgei $1, 0x4000         # 此时$1大于0x4000, 所以发生自陷异常
    
    ori $1, $0, 0x7000      # $1=0x00007000
    tgeiu $1, 0x7000        # 此时$1等于0x7000, 所以发生自陷异常
    
    ori $1, $0, 0x8000      # $1=0x00008000
    tgeu $1, $2             # 此时$1大于$2, 所以发生自陷异常
    
    ori $1, $0, 0x9000      # $1=0x00009000
    tlt $1, $2              # 此时$1不小于$2, 所以不发生自陷异常
    
    ori $1, $0, 0xa000      # $1=0x0000a000
    tlti $1, 0x9000         # 此时$1不小于0Xffff9000, 所以不发生自陷异常


    ori $1, $0, 0xb000      # $1=0x0000b000
    tltiu $1, 0xb000        # 此时$1小于0xffffb000, 所以发生自陷异常
    
    ori $1, $0, 0xc000      # $1=0x0000c000
    tltu $2, $1             # 此时$2小于$1, 所以发生自陷异常
    
    ori $1, $0, 0xd000      # 最后, 设置寄存器$1=0x0000d000
_loop:
    j _loop 
    nop