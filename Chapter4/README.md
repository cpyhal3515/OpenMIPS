# 第四章：第一条指令 ori 实现
## 1、ori 指令的格式
<div align=center><img src=./Picture/1.png width = 80% ></div>

指令的用法为：`ori rt,rs,immediate ` 作用是将指令中的 16 位立即数 immediate 进行**无符号扩展**至 32 位，然后与索引为 rs 的通用寄存器的值进行逻辑“或”运算，运算结果保存到索引为 rt 的通用寄存器中。

## 2、流水线的构建
流水线由组合逻辑以及 D 触发器组成，其中组合逻辑主要完成功能， D 触发器完成打拍操作。
<div align=center><img src=./Picture/2.png></div>

五级流水线由以下五级组成：
* 取指：取出指令存储器中的指令，PC值递增，准备取下一条指令。
* 译码：对指令进行译码，依据译码结果，从 32 个通用寄存器中取出源操作数，有的指令要求两个源操作数都是寄存器的值，有的指令要求其中一个源操作数是指令中立即数的扩展，所以这里有两个复用器，用于依据指令要求，确定参与运算的操作数，最终确定的两个操作数会送到执行阶段。
* 执行阶段：依据译码阶段送入的源操作数、操作码，进行运算，对于 ori 指令而言，就是进行逻辑“或”运算，运算结果传递到访存阶段。
* 访存阶段：对于 ori 指令，在访存阶段没有任何操作，直接将运算结果向下传递到回写阶段。
* 回写阶段：将运算结果保存到目的寄存器。

## 3、系统结构图
<div align=center><img src=./Picture/3.png></div>

下面给出各个模块的关键点的说明：
* 取指 pc_reg.v：因为是按字寻址，因此地址每次增加 4。
* 译码：
    * regfile.v：定义了 32 个 32 bit 的通用寄存器。同时要完成写操作、读端口1、读端口2 的操作。
    * id.v：对指令进行译码。确定运算的源操作数1、确定运算的源操作数2。
* 执行 ex.v：
    * 依据 aluop_i 指示的运算子类型进行运算。
    * 依据 aluse_i 指示的运算类型选择输出结果。
* 访存 mem.v：通路，这里暂时没有用到。
* 回写 mem_wb.v：写回通用寄存器中。

## 4、最小 SOPC 系统的实现
<div align=center><img src=./Picture/4.png width = 60% ></div>
在第三节中主要实现的是 OpenMIPS 的主体模块结构，为了形成最小 SOPC 系统，还需要给 OpenMIPS 的主体模块增加指令寄存器部分 inst_rom.v。指令寄存器中的内容通过编译 inst_rom.S 生成 inst_rom.data 的指令数据。
